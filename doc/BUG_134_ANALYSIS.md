# `134_many_dimensions` 段错误 Bug 分析与修复

## 摘要

测试案例 `134_many_dimensions` 暴露了 ARM32 后端中一个潜伏已久的、由两个独立但相互作用的 Bug 导致的严重问题。单独修复任何一个都无法解决问题，反而会引起回归。只有同时理解并修复这两个 Bug，才能彻底解决该测试案例的段错误，并保证其他所有测试案例（包括涉及矩阵运算的案例）的正确性。

最终的修复使测试通过率从 99.3% (143/144) 提升至 100% (144/144)，完全消除了所有段错误。

## 问题症状

`134_many_dimensions` 测试案例在运行时稳定地触发段错误 (SIGSEGV)。该案例的特点是定义了一个 19 维的数组，并调用一个接收 19 个不同维度（从 1 维到 19 维）数组指针作为参数的函数 `sum`。

## Bug 1: 调用者错误：参数类型混淆导致指针被解引用为值

### 根源

在 `main` 函数为 `sum` 函数准备参数时，尤其是处理需要通过栈传递的参数（第 5 个及以后），编译器犯了一个致命错误。

当一个 `N` 维数组作为参数传递时，它会"退化"为一个指向其 `N-1` 维子数组的指针。`main` 函数本应将这些子数组的**地址**压入栈中。

然而，在 `backend/arm32/CodeGeneratorArm32.cpp` 的 `adjustFuncCallInsts` 函数中，为这些栈上传递的参数创建临时内存变量时，代码错误地写死了类型为 `IntegerType::getTypeInt()`：

```cpp
// 错误的旧代码
MemVariable * newVal = func->newMemVariable(IntegerType::getTypeInt());
```

这导致后续的 `translate_assign` 指令混淆了参数的类型。它认为目标是一个普通的整型变量，而不是一个指针。因此，它错误地执行了"加载指针指向的值" (`value = *ptr`) 的操作，而不是简单的"指针赋值" (`ptr = ptr`)。最终，`main` 函数将一个本应是指针的地址解引用成了一个整数值，并将这个**值**压入了栈。

### 后果

`sum` 函数期望从栈上接收一个地址，但实际上收到了一个无意义的整数。当 `sum` 函数尝试将这个整数作为地址来访问内存时，直接导致了非法内存访问，引发段错误。

### 修复

修复方法是确保创建的临时内存变量与原始参数的类型完全一致：

```cpp
// 正确的修复后代码
MemVariable * newVal = func->newMemVariable(arg->getType());
```

这样，`translate_assign` 就能正确识别出这是一个指针到指针的赋值，从而传递正确的地址。

## Bug 2: 被调用者错误：栈帧偏移量计算错误

### 根源

ARM32 的过程调用标准 (AAPCS) 规定，当一个函数（调用者）通过 `bl` 指令调用另一个函数（被调用者）时，返回地址会被存放在链接寄存器 (`LR`) 中。如果被调用者自己也需要调用其他函数（即它是一个**非叶函数**），它必须在自己的函数序言中将 `LR` 的值保存到栈上，以防 `LR` 被新的函数调用覆盖。

在 `sum` 函数中，由于调用了外部函数 `printf`，它是一个非叶函数。因此，其栈帧布局应该是：
- `[fp, #0]`: 保存的调用者 `r10`
- `[fp, #4]`: 保存的调用者 `fp`
- `[fp, #8]`: **保存的返回地址 `LR`**
- `[fp, #12]`: 第一个栈上传递的参数（即第 5 个总参数）

然而，在 `adjustFormalParamInsts` 函数中，用于判断是否为非叶函数的逻辑 (`func->getExistFuncCall()`) 存在缺陷。它在被调用前没能正确识别出 `sum` 函数包含一个函数调用。因此，编译器错误地认为 `sum` 是一个**叶函数**，没有为 `LR` 预留空间。它从 `[fp, #8]` 开始计算栈参数的偏移量。

### 后果

当 `sum` 函数尝试从 `[fp, #8]` 加载第一个栈参数时，它实际加载到的是 `LR` 的值（一个代码地址）。后续代码将这个代码地址当作数据指针进行运算和解引用，这是段错误的另一个直接原因。

### 修复

最可靠的修复方法是在 `adjustFuncCallInsts` 函数中，一旦检测到 `FuncCallInstruction`，就立刻将当前函数标记为非叶函数：

```cpp
// 在 adjustFuncCallInsts 内部
if (Instanceof(callInst, FuncCallInstruction *, *pIter)) {
    // 立即设置标志，确保后续偏移计算正确
    func->setExistFuncCall(true);
    // ...
}
```

这确保了无论何时调用 `adjustFormalParamInsts`，`getExistFuncCall` 标志都已经是正确的，从而为栈参数计算出正确的偏移量（从 `[fp, #12]` 开始）。

## 结论

这两个 Bug 相互关联，共同导致了 `134_many_dimensions` 的失败。
- Bug 1（调用者错误）导致传递了错误的**数据**（值而非指针）。
- Bug 2（被调用者错误）导致从错误的**地址**（`[fp, #8]` 而非 `[fp, #12]`）读取数据。

单独修复任何一个都无法成功。例如，只修复 Bug 2，`sum` 函数会从 `[fp, #12]` 开始读取，但 `main` 仍然压入的是错误的值。只修复 Bug 1，`main` 会压入正确的地址，但 `sum` 函数会从 `[fp, #8]` 读取 `LR`，仍然导致崩溃。

只有同时修复这两个问题，才能保证 `main` 函数正确地将**地址**压入栈，并且 `sum` 函数从正确的**偏移量**处读取这些地址，从而彻底解决这个棘手的 Bug。 