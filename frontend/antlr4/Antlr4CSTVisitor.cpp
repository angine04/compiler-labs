///
/// @file Antlr4CSTVisitor.cpp
/// @brief Antlr4的具体语法树的遍历产生AST
/// @author zenglj (zenglj@live.com)
/// @version 1.1
/// @date 2024-11-23
///
/// @copyright Copyright (c) 2024
///
/// @par 修改日志:
/// <table>
/// <tr><th>Date       <th>Version <th>Author  <th>Description
/// <tr><td>2024-09-29 <td>1.0     <td>zenglj  <td>新建
/// <tr><td>2024-11-23 <td>1.1     <td>zenglj  <td>表达式版增强
/// </table>
///

#include <string>

#include "Antlr4CSTVisitor.h"
#include "AST.h"
#include "AttrType.h"
#include "autogenerated/MiniCLexer.h"

#define Instanceof(res, type, var) auto res = dynamic_cast<type>(var)

/// @brief 构造函数
MiniCCSTVisitor::MiniCCSTVisitor()
{}

/// @brief 析构函数
MiniCCSTVisitor::~MiniCCSTVisitor()
{}

/// @brief 遍历CST产生AST
/// @param root CST语法树的根结点
/// @return AST的根节点
ast_node * MiniCCSTVisitor::run(MiniCParser::CompileUnitContext * root)
{
    return std::any_cast<ast_node *>(visitCompileUnit(root));
}

/// @brief 非终结运算符compileUnit的遍历
/// @param ctx CST上下文
std::any MiniCCSTVisitor::visitCompileUnit(MiniCParser::CompileUnitContext * ctx)
{
    // compileUnit: (funcDef | varDecl)* EOF

    // 请注意这里必须先遍历全局变量后遍历函数。肯定可以确保全局变量先声明后使用的规则，但有些情况却不能检查出。
    // 事实上可能函数A后全局变量B后函数C，这时在函数A中是不能使用变量B的，需要报语义错误，但目前的处理不会。
    // 因此在进行语义检查时，可能追加检查行号和列号，如果函数的行号/列号在全局变量的行号/列号的前面则需要报语义错误
    // TODO 请追加实现。

    ast_node * temp_node;
    ast_node * compileUnitNode = create_contain_node(ast_operator_type::AST_OP_COMPILE_UNIT);

    // 可能多个变量，因此必须循环遍历
    for (auto varCtx: ctx->varDecl()) {

        // 变量函数定义
        temp_node = std::any_cast<ast_node *>(visitVarDecl(varCtx));
        (void) compileUnitNode->insert_son_node(temp_node);
    }

    // 可能有多个函数，因此必须循环遍历
    for (auto funcCtx: ctx->funcDef()) {

        // 变量函数定义
        temp_node = std::any_cast<ast_node *>(visitFuncDef(funcCtx));
        (void) compileUnitNode->insert_son_node(temp_node);
    }

    return compileUnitNode;
}

/// @brief 非终结运算符funcDef的遍历
/// @param ctx CST上下文
std::any MiniCCSTVisitor::visitFuncDef(MiniCParser::FuncDefContext * ctx)
{
    // 识别的文法产生式：funcDef : (T_INT | T_VOID) T_ID T_L_PAREN formalParamList? T_R_PAREN block;

    // 函数返回类型，终结符
    type_attr funcReturnType;
    if (ctx->T_INT()) {
        funcReturnType = {BasicType::TYPE_INT, (int64_t) ctx->T_INT()->getSymbol()->getLine()};
    } else if (ctx->T_VOID()) {
        funcReturnType = {BasicType::TYPE_VOID, (int64_t) ctx->T_VOID()->getSymbol()->getLine()};
    }

    // 创建函数名的标识符终结符节点，终结符
    char * id = strdup(ctx->T_ID()->getText().c_str());

    var_id_attr funcId{id, (int64_t) ctx->T_ID()->getSymbol()->getLine()};

    // 形参结点处理
    ast_node * formalParamsNode = nullptr;
    if (ctx->formalParamList()) {
        formalParamsNode = std::any_cast<ast_node *>(visitFormalParamList(ctx->formalParamList()));
    }

    // 遍历block结点创建函数体节点，非终结符
    auto blockNode = std::any_cast<ast_node *>(visitBlock(ctx->block()));

    // 创建函数定义的节点，孩子有类型，函数名，语句块和形参
    // create_func_def函数内会释放funcId中指向的标识符空间，切记，之后不要再释放，之前一定要是通过strdup函数或者malloc分配的空间
    return create_func_def(funcReturnType, funcId, blockNode, formalParamsNode);
}

/// @brief 非终结运算符block的遍历
/// @param ctx CST上下文
std::any MiniCCSTVisitor::visitBlock(MiniCParser::BlockContext * ctx)
{
    // 识别的文法产生式：block : T_L_BRACE blockItemList? T_R_BRACE';
    if (!ctx->blockItemList()) {
        // 语句块没有语句

        // 为了方便创建一个空的Block节点
        return create_contain_node(ast_operator_type::AST_OP_BLOCK);
    }

    // 语句块含有语句

    // 内部创建Block节点，并把语句加入，这里不需要创建Block节点
    return visitBlockItemList(ctx->blockItemList());
}

/// @brief 非终结运算符blockItemList的遍历
/// @param ctx CST上下文
std::any MiniCCSTVisitor::visitBlockItemList(MiniCParser::BlockItemListContext * ctx)
{
    // 识别的文法产生式：blockItemList : blockItem +;
    // 正闭包 循环 至少一个blockItem
    auto block_node = create_contain_node(ast_operator_type::AST_OP_BLOCK);

    for (auto blockItemCtx: ctx->blockItem()) {

        // 非终结符，需遍历
        auto blockItem = std::any_cast<ast_node *>(visitBlockItem(blockItemCtx));

        // 插入到块节点中
        if (blockItem) {
            (void) block_node->insert_son_node(blockItem);
        }
    }

    return block_node;
}

/// @brief 非终结运算符blockItem的遍历
/// @param ctx CST上下文
///
std::any MiniCCSTVisitor::visitBlockItem(MiniCParser::BlockItemContext * ctx)
{
    // 识别的文法产生式：blockItem : statement | varDecl
    if (ctx->statement()) {
        // 语句识别
        // dispatch to the appropriate labeled alternative of statement
        return visit(ctx->statement());
    } else if (ctx->varDecl()) {
        return visitVarDecl(ctx->varDecl());
    }

    return nullptr;
}

/// @brief 非终结运算符expr的遍历
/// @param ctx CST上下文
std::any MiniCCSTVisitor::visitExpr(MiniCParser::ExprContext * ctx)
{
    //识别产生式：expr: logicalOrExpr;
    return visit(ctx->logicalOrExpr()); // Dispatch to the next level of precedence
}

// Implement new pass-through visitors
std::any MiniCCSTVisitor::visitPassToMulExpr(MiniCParser::PassToMulExprContext * ctx)
{
    return visit(ctx->mulExpr());
}

std::any MiniCCSTVisitor::visitPassToUnaryExpr(MiniCParser::PassToUnaryExprContext * ctx)
{
    return visit(ctx->unaryExpr());
}

std::any MiniCCSTVisitor::visitPassToPrimaryExpr(MiniCParser::PassToPrimaryExprContext * ctx)
{
    return visit(ctx->primaryExpr());
}

// Implement Parenthesized Expression
std::any MiniCCSTVisitor::visitParenthesizedExpr(MiniCParser::ParenthesizedExprContext * ctx)
{
    return visit(ctx->expr()); // Evaluate the inner expression
}

// Implement Integer Atom (which delegates to IntegerLiteral)
std::any MiniCCSTVisitor::visitIntegerAtom(MiniCParser::IntegerAtomContext * ctx)
{
    return visit(ctx->integerLiteral());
}

// Implement LVal Atom (delegates to LVal)
std::any MiniCCSTVisitor::visitLValAtom(MiniCParser::LValAtomContext * ctx)
{
    return visit(ctx->lVal());
}

// Restore/Confirm visitLVal if it was removed by the previous edit block comment
std::any MiniCCSTVisitor::visitLVal(MiniCParser::LValContext * ctx)
{
    // 识别文法产生式：lVal: T_ID (T_L_BRACKET expr T_R_BRACKET)*;
    // 获取ID的名字
    auto varIdText = ctx->T_ID()->getText();
    char * varId = strdup(varIdText.c_str());

    // 获取行号
    int64_t lineNo = (int64_t) ctx->T_ID()->getSymbol()->getLine();

    // Assuming var_id_attr has only {char* id, int64_t lineno}
    var_id_attr id_attr = {varId, lineNo};
    
    // Create the base ID node
    ast_node * base_node = ast_node::New(id_attr);

    // 检查是否有数组访问
    if (ctx->expr().empty()) {
        // 没有数组访问，返回简单的ID节点
        return std::any(base_node);
    } else {
        // 有数组访问，创建数组维度容器节点包含所有索引表达式
        ast_node * array_dims = create_contain_node(ast_operator_type::AST_OP_ARRAY_DIM);
        
        for (auto exprCtx : ctx->expr()) {
            // 访问数组索引表达式
            auto index_node = std::any_cast<ast_node *>(visit(exprCtx));
            // 将索引表达式添加到维度容器中
            (void) array_dims->insert_son_node(index_node);
        }
        
        // 创建单个数组访问节点，包含变量名和所有维度
        ast_node * array_ref = create_contain_node(ast_operator_type::AST_OP_ARRAY_REF, base_node, array_dims);
        
        return std::any(array_ref);
    }
}

// Implement IntegerLiteral to handle different bases
std::any MiniCCSTVisitor::visitIntegerLiteral(MiniCParser::IntegerLiteralContext * ctx)
{
    antlr4::Token * token;
    uint32_t val;
    std::string text;
    int64_t lineNo;

    if (ctx->T_HEX_LITERAL()) {
        token = ctx->T_HEX_LITERAL()->getSymbol();
        text = token->getText();
        lineNo = token->getLine();
        // Remove "0x" or "0X" prefix for stoul
        val = static_cast<uint32_t>(std::stoul(text.substr(2), nullptr, 16));
    } else if (ctx->T_OCT_LITERAL()) {
        token = ctx->T_OCT_LITERAL()->getSymbol();
        text = token->getText();
        lineNo = token->getLine();
        // std::stoul with base 8 handles strings like "0123" directly if the '0' is part of the octal number
        // If T_OCT_LITERAL rule is '0'[0-7]+, text will be like "012", "077"
        val = static_cast<uint32_t>(std::stoul(text, nullptr, 8));
    } else if (ctx->T_DEC_LITERAL()) {
        token = ctx->T_DEC_LITERAL()->getSymbol();
        text = token->getText();
        lineNo = token->getLine();
        val = static_cast<uint32_t>(std::stoul(text, nullptr, 10));
    } else {
        // Should not happen if grammar is correct and complete
        // Consider throwing an error or returning a specific error AST node
        return nullptr;
    }

    digit_int_attr val_attr = {val, lineNo};
    return std::any(ast_node::New(val_attr));
}

// Implement Negation Expression
std::any MiniCCSTVisitor::visitNegationExpr(MiniCParser::NegationExprContext * ctx)
{
    auto operand = std::any_cast<ast_node *>(visit(ctx->unaryExpr()));
    if (!operand) {
        // Error handling or specific logging if needed
        return nullptr;
    }
    return std::any(create_contain_node(ast_operator_type::AST_OP_NEG, operand));
}

// Implement Function Call Atom
std::any MiniCCSTVisitor::visitFunctionCallAtom(MiniCParser::FunctionCallAtomContext * ctx)
{
    char * funcName = strdup(ctx->T_ID()->getText().c_str());
    int64_t lineNo = ctx->T_ID()->getSymbol()->getLine();
    // Assuming var_id_attr has only {char* id, int64_t lineno}
    var_id_attr func_id_attr = {funcName, lineNo};
    ast_node * func_name_node = ast_node::New(func_id_attr);

    ast_node * paramListNode = nullptr;
    if (ctx->realParamList()) {
        paramListNode = std::any_cast<ast_node *>(visit(ctx->realParamList()));
    } else {
        // Use AST_OP_FUNC_REAL_PARAMS for empty args list node type
        paramListNode = create_contain_node(ast_operator_type::AST_OP_FUNC_REAL_PARAMS);
    }

    return std::any(create_func_call(func_name_node, paramListNode));
}

// Ensure visitRealParamList is implemented correctly to return an AST_OP_FUNC_REAL_PARAMS node
std::any MiniCCSTVisitor::visitRealParamList(MiniCParser::RealParamListContext * ctx)
{
    //识别文法产生式：realParamList: expr (T_COMMA expr)*;
    // Use AST_OP_FUNC_REAL_PARAMS for the argument list container node type
    ast_node * argsNode = create_contain_node(ast_operator_type::AST_OP_FUNC_REAL_PARAMS);

    for (auto exprCtx: ctx->expr()) {
        auto argNode = std::any_cast<ast_node *>(visit(exprCtx));
        if (argNode) {
            (void) argsNode->insert_son_node(argNode);
        }
    }
    return std::any(argsNode);
}

// Implement Add/Sub Expression
std::any MiniCCSTVisitor::visitAddSubExpr(MiniCParser::AddSubExprContext * ctx)
{
    // 使用迭代代替递归来避免栈溢出
    std::vector<MiniCParser::MulExprContext *> mulExprs;
    std::vector<antlr4::Token *> ops;

    MiniCParser::AddExprContext *current = ctx;
    while (auto addSubCtx = dynamic_cast<MiniCParser::AddSubExprContext *>(current)) {
        mulExprs.push_back(addSubCtx->mulExpr());
        ops.push_back(addSubCtx->T_ADD() ? addSubCtx->T_ADD()->getSymbol() : addSubCtx->T_SUB()->getSymbol());
        current = addSubCtx->addExpr();
    }
    // current 现在是 PassToMulExprContext
    mulExprs.push_back(dynamic_cast<MiniCParser::PassToMulExprContext *>(current)->mulExpr());

    std::reverse(mulExprs.begin(), mulExprs.end());
    std::reverse(ops.begin(), ops.end());

    ast_node *left = std::any_cast<ast_node *>(visit(mulExprs[0]));
    for (size_t i = 0; i < ops.size(); ++i) {
        ast_node *right = std::any_cast<ast_node *>(visit(mulExprs[i + 1]));
        ast_operator_type op_type = (ops[i]->getType() == MiniCLexer::T_ADD) ? ast_operator_type::AST_OP_ADD
                                                                            : ast_operator_type::AST_OP_SUB;
        left = create_contain_node(op_type, left, right);
    }
    return std::any(left);
}

// Implement Mul/Div/Mod Expression
std::any MiniCCSTVisitor::visitMulDivModExpr(MiniCParser::MulDivModExprContext * ctx)
{
    // 使用迭代代替递归
    std::vector<MiniCParser::UnaryExprContext *> unaryExprs;
    std::vector<antlr4::Token *> ops;

    MiniCParser::MulExprContext *current = ctx;
    while (auto mulDivModCtx = dynamic_cast<MiniCParser::MulDivModExprContext *>(current)) {
        unaryExprs.push_back(mulDivModCtx->unaryExpr());
        if (mulDivModCtx->T_MUL()) ops.push_back(mulDivModCtx->T_MUL()->getSymbol());
        else if (mulDivModCtx->T_DIV()) ops.push_back(mulDivModCtx->T_DIV()->getSymbol());
        else ops.push_back(mulDivModCtx->T_MOD()->getSymbol());
        current = mulDivModCtx->mulExpr();
    }
    unaryExprs.push_back(dynamic_cast<MiniCParser::PassToUnaryExprContext *>(current)->unaryExpr());

    std::reverse(unaryExprs.begin(), unaryExprs.end());
    std::reverse(ops.begin(), ops.end());

    ast_node *left = std::any_cast<ast_node *>(visit(unaryExprs[0]));
    for (size_t i = 0; i < ops.size(); ++i) {
        ast_node *right = std::any_cast<ast_node *>(visit(unaryExprs[i + 1]));
        ast_operator_type op_type;
        if (ops[i]->getType() == MiniCLexer::T_MUL) op_type = ast_operator_type::AST_OP_MUL;
        else if (ops[i]->getType() == MiniCLexer::T_DIV) op_type = ast_operator_type::AST_OP_DIV;
        else op_type = ast_operator_type::AST_OP_MOD;
        left = create_contain_node(op_type, left, right);
    }
    return std::any(left);
}

std::any MiniCCSTVisitor::visitAssignStatement(MiniCParser::AssignStatementContext * ctx)
{
    // 识别文法产生式：assignStatement: lVal T_ASSIGN expr T_SEMICOLON

    // 赋值左侧左值Lval遍历产生节点
    auto lvalNode = std::any_cast<ast_node *>(visitLVal(ctx->lVal()));

    // 赋值右侧expr遍历
    auto exprNode = std::any_cast<ast_node *>(visitExpr(ctx->expr()));

    // 创建一个AST_OP_ASSIGN类型的中间节点，孩子为Lval和Expr
    return ast_node::New(ast_operator_type::AST_OP_ASSIGN, lvalNode, exprNode, nullptr);
}

std::any MiniCCSTVisitor::visitBlockStatement(MiniCParser::BlockStatementContext * ctx)
{
    // 识别文法产生式 blockStatement: block

    return visitBlock(ctx->block());
}

std::any MiniCCSTVisitor::visitVarDecl(MiniCParser::VarDeclContext * ctx)
{
    // varDecl: basicType varDef (T_COMMA varDef)* T_SEMICOLON;

    // 声明语句节点
    ast_node * stmt_node = create_contain_node(ast_operator_type::AST_OP_DECL_STMT);

    // 类型节点
    type_attr typeAttr = std::any_cast<type_attr>(visitBasicType(ctx->basicType()));

    for (auto & varCtx: ctx->varDef()) {
        // 变量定义节点（可能是ID节点、初始化节点或数组声明节点）
        ast_node * var_node = std::any_cast<ast_node *>(visitVarDef(varCtx));

        // 创建类型节点
        ast_node * type_node = create_type_node(typeAttr);

        ast_node * decl_node;
        if (var_node->node_type == ast_operator_type::AST_OP_VAR_INIT) {
            // 初始化节点，需要将类型节点作为第一个孩子
            decl_node = var_node;
            // 在flex/bison中，init节点的结构是 (VAR_INIT (VAR_DECL type id) expr)
            // 或 (VAR_INIT (ARRAY_DECL id dims) expr)
            // 我们的var_node是 (VAR_INIT (ID or ARRAY_DECL) expr)
            // 我们需要将类型信息注入。最简单的方法是设置类型字段。
            var_node->sons[0]->type = type_node->type;
            ast_node::Delete(type_node);
            
        } else if (var_node->node_type == ast_operator_type::AST_OP_ARRAY_DECL) {
            // 数组声明节点，需要设置其类型
            decl_node = var_node;
            decl_node->type = type_node->type;
            // 确保其下的ID节点也有类型信息
            if (!decl_node->sons.empty() && decl_node->sons[0]->node_type == ast_operator_type::AST_OP_LEAF_VAR_ID) {
                decl_node->sons[0]->type = type_node->type;
            }
            ast_node::Delete(type_node);
        } else {
            // 普通ID节点，创建变量声明节点
            decl_node = ast_node::New(ast_operator_type::AST_OP_VAR_DECL, type_node, var_node, nullptr);
        }

        // 插入到变量声明语句
        (void) stmt_node->insert_son_node(decl_node);
    }

    return stmt_node;
}

std::any MiniCCSTVisitor::visitVarDef(MiniCParser::VarDefContext * ctx)
{
    // varDef: T_ID (T_L_BRACKET T_DEC_LITERAL T_R_BRACKET)* (T_ASSIGN expr)?;

    auto varId = ctx->T_ID()->getText();

    // 获取行号
    int64_t lineNo = (int64_t) ctx->T_ID()->getSymbol()->getLine();

    // 创建基础的变量ID节点
    ast_node * id_node = ast_node::New(varId, lineNo);

    // 处理数组维度 (T_L_BRACKET T_DEC_LITERAL T_R_BRACKET)*
    ast_node * var_node = id_node;
    if (!ctx->T_DEC_LITERAL().empty()) {
        // 有数组维度，创建数组声明节点
        
        // 首先创建数组维度容器节点 (AST_OP_ARRAY_DIM)
        ast_node * array_dims = create_contain_node(ast_operator_type::AST_OP_ARRAY_DIM);
        
        // 为每个维度添加大小节点到容器中
        for (auto decLiteral : ctx->T_DEC_LITERAL()) {
            std::string text = decLiteral->getText();
            uint32_t val = static_cast<uint32_t>(std::stoul(text, nullptr, 10));
            int64_t decLineNo = decLiteral->getSymbol()->getLine();
            digit_int_attr dim_attr = {val, decLineNo};
            ast_node * dim_node = ast_node::New(dim_attr);
            (void) array_dims->insert_son_node(dim_node);
        }
        
        // 创建数组声明节点，包含ID节点和维度容器节点
        var_node = create_contain_node(ast_operator_type::AST_OP_ARRAY_DECL, id_node, array_dims);
    }

    // 检查是否有初始化表达式
    if (ctx->expr()) {
        // 有初始化值
        ast_node * expr_node = std::any_cast<ast_node *>(visitExpr(ctx->expr()));

        // 创建初始化节点
        return ast_node::New(ast_operator_type::AST_OP_VAR_INIT, var_node, expr_node, nullptr);
    } else {
        // 没有初始化值，返回变量节点（可能是ID节点或数组声明节点）
        return var_node;
    }
}

std::any MiniCCSTVisitor::visitBasicType(MiniCParser::BasicTypeContext * ctx)
{
    // basicType: T_INT;
    type_attr attr{BasicType::TYPE_VOID, -1};
    if (ctx->T_INT()) {
        attr.type = BasicType::TYPE_INT;
        attr.lineno = (int64_t) ctx->T_INT()->getSymbol()->getLine();
    }

    return attr;
}

std::any MiniCCSTVisitor::visitExpressionStatement(MiniCParser::ExpressionStatementContext * ctx)
{
    // 识别文法产生式  expr ? T_SEMICOLON #expressionStatement;
    if (ctx->expr()) {
        // 表达式语句

        // 遍历expr非终结符，创建表达式节点后返回
        return visitExpr(ctx->expr());
    } else {
        // 空语句
        // 返回一个专门的空语句节点
        return create_contain_node(ast_operator_type::AST_OP_EMPTY_STMT);
    }
}

///
/// @brief 非终结运算符statement中的returnStatement的遍历
/// @param ctx CST上下文
///
std::any MiniCCSTVisitor::visitReturnStatement(MiniCParser::ReturnStatementContext * ctx)
{
    // 识别的文法产生式：returnStatement -> T_RETURN expr? T_SEMICOLON

    ast_node * exprNode = nullptr;
    if (ctx->expr()) {
        exprNode = std::any_cast<ast_node *>(visitExpr(ctx->expr()));
    }

    // 创建返回节点，其孩子为Expr（可能为nullptr）
    return create_contain_node(ast_operator_type::AST_OP_RETURN, exprNode);
}

/// @brief 非终结符FormalParamList的分析
/// @param ctx CST上下文
std::any MiniCCSTVisitor::visitFormalParamList(MiniCParser::FormalParamListContext * ctx)
{
    // 识别文法产生式：formalParamList: formalParam (T_COMMA formalParam)*;
    ast_node * paramsNode = create_contain_node(ast_operator_type::AST_OP_FUNC_FORMAL_PARAMS);

    for (auto paramCtx: ctx->formalParam()) {
        auto paramNode = std::any_cast<ast_node *>(visitFormalParam(paramCtx));
        if (paramNode) {
            (void) paramsNode->insert_son_node(paramNode);
        }
    }
    return std::any(paramsNode);
}

/// @brief 非终结符FormalParam的分析
/// @param ctx CST上下文
std::any MiniCCSTVisitor::visitFormalParam(MiniCParser::FormalParamContext * ctx)
{
    // 识别文法产生式：formalParam: basicType T_ID arraySpecifier*;

    // 获取类型信息
    type_attr typeAttr = std::any_cast<type_attr>(visitBasicType(ctx->basicType()));

    // 获取参数名
    char * paramName = strdup(ctx->T_ID()->getText().c_str());
    int64_t lineNo = (int64_t) ctx->T_ID()->getSymbol()->getLine();

    var_id_attr paramId{paramName, lineNo};

    // 创建基础的参数名节点
    ast_node * id_node = ast_node::New(paramId);

    // 处理数组维度
    if (!ctx->arraySpecifier().empty()) {
        ast_node * array_dims = create_contain_node(ast_operator_type::AST_OP_ARRAY_DIM);
        
        for (auto specifierCtx : ctx->arraySpecifier()) {
            if (specifierCtx->T_DEC_LITERAL()) {
                // 有数字字面量
                auto decLiteral = specifierCtx->T_DEC_LITERAL();
                std::string text = decLiteral->getText();
                uint32_t val = static_cast<uint32_t>(std::stoul(text, nullptr, 10));
                int64_t decLineNo = decLiteral->getSymbol()->getLine();
                digit_int_attr dim_attr = {val, decLineNo};
                ast_node * dim_node = ast_node::New(dim_attr);
                (void) array_dims->insert_son_node(dim_node);
            } else {
                // 空维度，创建一个特殊的空维度节点
                ast_node * empty_dim = create_contain_node(ast_operator_type::AST_OP_EMPTY_DIM);
                (void) array_dims->insert_son_node(empty_dim);
            }
        }
        
        ast_node * array_param_node = create_contain_node(ast_operator_type::AST_OP_ARRAY_DECL, id_node, array_dims);
        id_node = array_param_node;
    }

    // 创建类型节点
    ast_node * type_node = create_type_node(typeAttr);

    // 创建形参节点
    return ast_node::New(ast_operator_type::AST_OP_FUNC_FORMAL_PARAM, type_node, id_node, nullptr);
}

// 新增的控制流语句实现
std::any MiniCCSTVisitor::visitIfStatement(MiniCParser::IfStatementContext* ctx) {
    // 使用迭代代替递归来处理 if-else-if 链
    
    std::vector<ast_node*> conditions;
    std::vector<ast_node*> then_stmts;
    ast_node* final_else_stmt = nullptr;

    auto* current_if_ctx = ctx;

    while (current_if_ctx != nullptr) {
        // 收集当前 if 的条件和 then 分支
        conditions.push_back(std::any_cast<ast_node*>(visit(current_if_ctx->expr())));
        then_stmts.push_back(std::any_cast<ast_node*>(visit(current_if_ctx->statement(0))));

        // 检查 else 分支
        if (current_if_ctx->statement().size() > 1) {
            auto* else_stmt_ctx = current_if_ctx->statement(1);
            if (else_stmt_ctx && !else_stmt_ctx->children.empty()) {
                // 尝试将子节点转换为IfStatementContext
                auto* next_if_ctx = dynamic_cast<MiniCParser::IfStatementContext*>(else_stmt_ctx->children[0]);
                if (next_if_ctx) {
                    // else-if 结构，继续循环
                    current_if_ctx = next_if_ctx;
                } else {
                    // 最后的 else 分支或非if语句的else
                    final_else_stmt = std::any_cast<ast_node*>(visit(else_stmt_ctx));
                    current_if_ctx = nullptr;
                }
            } else {
                // else 分支为空或没有子节点
                final_else_stmt = else_stmt_ctx ? std::any_cast<ast_node*>(visit(else_stmt_ctx)) : nullptr;
                current_if_ctx = nullptr;
            }
        } else {
            // 没有 else 分支
            current_if_ctx = nullptr;
        }
    }

    // 从后向前构建 if-else 链的 AST
    ast_node* root = final_else_stmt;

    for (int i = conditions.size() - 1; i >= 0; --i) {
        ast_node* condition = conditions[i];
        ast_node* then_stmt = then_stmts[i];
        root = create_contain_node(ast_operator_type::AST_OP_IF, condition, then_stmt, root);
    }

    return root;
}

std::any MiniCCSTVisitor::visitWhileStatement(MiniCParser::WhileStatementContext * ctx)
{
    // 识别文法产生式：T_WHILE T_L_PAREN expr T_R_PAREN statement
    
    // 获取条件表达式
    ast_node * condition = std::any_cast<ast_node *>(visit(ctx->expr()));
    
    // 获取循环体语句
    ast_node * body = std::any_cast<ast_node *>(visit(ctx->statement()));
    
    // 创建while节点
    return create_contain_node(ast_operator_type::AST_OP_WHILE, condition, body);
}

std::any MiniCCSTVisitor::visitBreakStatement(MiniCParser::BreakStatementContext * ctx)
{
    // 识别文法产生式：T_BREAK T_SEMICOLON
    return create_contain_node(ast_operator_type::AST_OP_BREAK);
}

std::any MiniCCSTVisitor::visitContinueStatement(MiniCParser::ContinueStatementContext * ctx)
{
    // 识别文法产生式：T_CONTINUE T_SEMICOLON
    return create_contain_node(ast_operator_type::AST_OP_CONTINUE);
}

// 新增的逻辑表达式实现
std::any MiniCCSTVisitor::visitLogicalOrOpExpr(MiniCParser::LogicalOrOpExprContext * ctx)
{
    // 使用迭代代替递归
    std::vector<MiniCParser::LogicalAndExprContext *> andExprs;
    MiniCParser::LogicalOrExprContext *current = ctx;
    while(auto orCtx = dynamic_cast<MiniCParser::LogicalOrOpExprContext *>(current)) {
        andExprs.push_back(orCtx->logicalAndExpr());
        current = orCtx->logicalOrExpr();
    }
    andExprs.push_back(dynamic_cast<MiniCParser::PassToLogicalAndExprContext *>(current)->logicalAndExpr());

    std::reverse(andExprs.begin(), andExprs.end());

    ast_node *left = std::any_cast<ast_node *>(visit(andExprs[0]));
    for (size_t i = 1; i < andExprs.size(); ++i) {
        ast_node *right = std::any_cast<ast_node *>(visit(andExprs[i]));
        left = create_contain_node(ast_operator_type::AST_OP_LOGICAL_OR, left, right);
    }
    return std::any(left);
}

std::any MiniCCSTVisitor::visitPassToLogicalAndExpr(MiniCParser::PassToLogicalAndExprContext * ctx)
{
    return visit(ctx->logicalAndExpr());
}

std::any MiniCCSTVisitor::visitLogicalAndOpExpr(MiniCParser::LogicalAndOpExprContext * ctx)
{
    // 使用迭代代替递归
    std::vector<MiniCParser::EqualityExprContext *> equalityExprs;
    MiniCParser::LogicalAndExprContext *current = ctx;
    while(auto andCtx = dynamic_cast<MiniCParser::LogicalAndOpExprContext *>(current)) {
        equalityExprs.push_back(andCtx->equalityExpr());
        current = andCtx->logicalAndExpr();
    }
    equalityExprs.push_back(dynamic_cast<MiniCParser::PassToEqualityExprContext *>(current)->equalityExpr());
    
    std::reverse(equalityExprs.begin(), equalityExprs.end());

    ast_node *left = std::any_cast<ast_node *>(visit(equalityExprs[0]));
    for (size_t i = 1; i < equalityExprs.size(); ++i) {
        ast_node *right = std::any_cast<ast_node *>(visit(equalityExprs[i]));
        left = create_contain_node(ast_operator_type::AST_OP_LOGICAL_AND, left, right);
    }
    return std::any(left);
}

std::any MiniCCSTVisitor::visitPassToEqualityExpr(MiniCParser::PassToEqualityExprContext * ctx)
{
    return visit(ctx->equalityExpr());
}

std::any MiniCCSTVisitor::visitEqualityOpExpr(MiniCParser::EqualityOpExprContext * ctx)
{
    // 使用迭代代替递归
    std::vector<MiniCParser::RelationalExprContext *> relationalExprs;
    std::vector<antlr4::Token *> ops;

    MiniCParser::EqualityExprContext *current = ctx;
    while(auto eqCtx = dynamic_cast<MiniCParser::EqualityOpExprContext *>(current)) {
        relationalExprs.push_back(eqCtx->relationalExpr());
        ops.push_back(eqCtx->T_EQ() ? eqCtx->T_EQ()->getSymbol() : eqCtx->T_NE()->getSymbol());
        current = eqCtx->equalityExpr();
    }
    relationalExprs.push_back(dynamic_cast<MiniCParser::PassToRelationalExprContext *>(current)->relationalExpr());

    std::reverse(relationalExprs.begin(), relationalExprs.end());
    std::reverse(ops.begin(), ops.end());

    ast_node *left = std::any_cast<ast_node *>(visit(relationalExprs[0]));
    for (size_t i = 0; i < ops.size(); ++i) {
        ast_node *right = std::any_cast<ast_node *>(visit(relationalExprs[i + 1]));
        ast_operator_type op_type = (ops[i]->getType() == MiniCLexer::T_EQ) ? ast_operator_type::AST_OP_EQ : ast_operator_type::AST_OP_NE;
        left = create_contain_node(op_type, left, right);
    }
    return std::any(left);
}

std::any MiniCCSTVisitor::visitPassToRelationalExpr(MiniCParser::PassToRelationalExprContext * ctx)
{
    return visit(ctx->relationalExpr());
}

std::any MiniCCSTVisitor::visitRelationalOpExpr(MiniCParser::RelationalOpExprContext * ctx)
{
    // 使用迭代代替递归
    std::vector<MiniCParser::AddExprContext *> addExprs;
    std::vector<antlr4::Token *> ops;

    MiniCParser::RelationalExprContext *current = ctx;
    while(auto relCtx = dynamic_cast<MiniCParser::RelationalOpExprContext *>(current)) {
        addExprs.push_back(relCtx->addExpr());
        if (relCtx->T_LT()) ops.push_back(relCtx->T_LT()->getSymbol());
        else if (relCtx->T_LE()) ops.push_back(relCtx->T_LE()->getSymbol());
        else if (relCtx->T_GT()) ops.push_back(relCtx->T_GT()->getSymbol());
        else ops.push_back(relCtx->T_GE()->getSymbol());
        current = relCtx->relationalExpr();
    }
    addExprs.push_back(dynamic_cast<MiniCParser::PassToAddExprContext *>(current)->addExpr());

    std::reverse(addExprs.begin(), addExprs.end());
    std::reverse(ops.begin(), ops.end());

    ast_node *left = std::any_cast<ast_node *>(visit(addExprs[0]));
    for (size_t i = 0; i < ops.size(); ++i) {
        ast_node *right = std::any_cast<ast_node *>(visit(addExprs[i + 1]));
        ast_operator_type op_type;
        if (ops[i]->getType() == MiniCLexer::T_LT) op_type = ast_operator_type::AST_OP_LT;
        else if (ops[i]->getType() == MiniCLexer::T_LE) op_type = ast_operator_type::AST_OP_LE;
        else if (ops[i]->getType() == MiniCLexer::T_GT) op_type = ast_operator_type::AST_OP_GT;
        else op_type = ast_operator_type::AST_OP_GE;
        left = create_contain_node(op_type, left, right);
    }
    return std::any(left);
}

std::any MiniCCSTVisitor::visitPassToAddExpr(MiniCParser::PassToAddExprContext * ctx)
{
    return visit(ctx->addExpr());
}

std::any MiniCCSTVisitor::visitLogicalNotExpr(MiniCParser::LogicalNotExprContext * ctx)
{
    // 识别文法产生式：T_LOGICAL_NOT unaryExpr
    ast_node * operand = std::any_cast<ast_node *>(visit(ctx->unaryExpr()));
    
    if (!operand) {
        return nullptr;
    }
    
    return create_contain_node(ast_operator_type::AST_OP_LOGICAL_NOT, operand);
}